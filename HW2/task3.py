# -*- coding: utf-8 -*-
"""LAB1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1RHqp8I9pbKa-TFEcK_Y5eE3_MggxBAnm

**TASK 3: AES-CBC and AES-OFB**
"""

!pip install pycrypto

"""**ENCRYPTION FOR CBC MODE**"""

from Crypto.Cipher import AES
from binascii import unhexlify
import numpy as np

plaintext = b'This is a long secret test message.'
key = b'\x01\x23\x45\x67\x89\xab\xcd\xef\x01\x23\x45\x67\x89\xab\xcd\xef'+ \
b'\x01\x23\x45\x67\x89\xab\xcd\xef\x01\x23\x45\x67\x89\xab\xcd\xef'
iv = b'\x00\x01\x02\x03\x04\x05\x06\x07\x08\x09\x10\x11\x12\x13\x14\x15'

##the block size for PCKS7 is 16
##the function takes byte object 'plaintext' as input and gives as output
##if the block is at size 16 in order to inhibit eliminating the elements in the block 
## we add 16 0s at the end so it indicates that last 2 bytes are the padding bytes
##if not 16, the remaining places are filled with the hex forms indicating the remaining places.
def pad(plaintext):
    if(len(plaintext)%16!=0):
        rem = len(plaintext)%16
        rem = 16-rem
        rem_space = rem
        while(rem>0):
            plaintext = plaintext + bytes(chr(rem_space),'utf-8')
            rem = rem - 1
        return plaintext  
    else:
        plaintext = plaintext + bytes("0000000000000000",'utf-8')
        return plaintext

print("non-padded plaintext in hex form:",plaintext.hex())
print("length of the non-padded plaintext: ",len(plaintext))
m = len(plaintext)
text = pad(plaintext)
n = len(text)
print("padded plaintext in hex version:",text.hex())
print("length of the padded plaintext: ",len(text))

# this function is for xoring the padded plaintext with IV/ ciphertexts and encrypting them with the key.
# the key and iv are determined outside of the function.
# we take the blocks of the padded plaintext and xor them with IV bitwise. Then with
# aescipher object we use the encrption fnc to encrypt the output o fthe XOR with the key.
# then we add the blocks together to get the full ciphertext
def encryption_xor(plaintext,key,iv):
    aescipher = AES.new(key, AES.MODE_ECB)
    j = 0
    ciphertext = b''
    while j <= len(plaintext)-16:
        plain_block = plaintext[j:j+16]
        xor = bytes([iv[i] ^ plain_block[i] for i in range(16)])
        cipher_block = aescipher.encrypt(xor)
        ciphertext = ciphertext + cipher_block
        j = j + 16
        iv = cipher_block
      
    return ciphertext

cipher = encryption_xor(text,key,iv)
print('cipher: ', cipher.hex())
print('length of ciphertext is: ', len(cipher))

"""**DECRYPTION FOR CBC**"""

def decrypt_xor(ciphertext,key,iv):
    j = 0
    aescipher = AES.new(key, AES.MODE_ECB)
    recovered_plaintext = b''
    while j <= len(ciphertext)-16:
        cipher_block = ciphertext[j:j+16]
        print("16 bytes cipher blocks: ",cipher_block)
        decrypted_text = aescipher.decrypt(cipher_block)
        plaintext_block = bytes([iv[i] ^ decrypted_text[i] for i in range(16)])
        recovered_plaintext += plaintext_block 
        j = j + 16
        iv = cipher_block

    return recovered_plaintext

iv = b'\x00\x01\x02\x03\x04\x05\x06\x07\x08\x09\x10\x11\x12\x13\x14\x15'
plaintext_padded = decrypt_xor(cipher,key,iv)
print("Data after decryption: ",plaintext_padded)
## for unpadding 
## n is the unpadded plaintext message length
## m is padded plaintext message length
unpad_size = n-m
plaintext = plaintext_padded[:-unpad_size]
print("Data after unpadding: ",plaintext)

"""**ENCRYPTION FOR OFB** 

"""

nonce = b'\x00\x01\x02\x03\x04\x05\x06\x07\x08\x09\x10\x11\x12\x13\x14\x15'
key = b'\x01\x23\x45\x67\x89\xab\xcd\xef\x01\x23\x45\x67\x89\xab\xcd\xef'+ \
b'\x01\x23\x45\x67\x89\xab\xcd\xef\x01\x23\x45\x67\x89\xab\xcd\xef'
plaintext = b'Hey my name is Deniz Aytemiz.'

def pad(plaintext):
    if(len(plaintext)%16!=0):
        rem = len(plaintext)%16
        rem = 16-rem
        rem_space = rem
        while(rem>0):
            plaintext = plaintext + bytes(chr(rem_space),'utf-8')
            rem = rem - 1
        return plaintext  
    else:
        plaintext = plaintext + bytes("0000000000000000",'utf-8')
        return plaintext

print(pad(plaintext))
padded_plaintext = pad(plaintext)
print(len(plaintext))
n = len(plaintext)
print(len(padded_plaintext))
m = len(padded_plaintext)

def encryption_OFB(plaintext,key,nonce):
    aescipher = AES.new(key, AES.MODE_ECB)
    j = 0
    ciphertext = b''
    while j <= len(plaintext)-16:
        plain_block = plaintext[j:j+16]
        out = aescipher.encrypt(nonce)
        cipher_block = bytes([out[i] ^ plain_block[i] for i in range(16)])
        ciphertext = ciphertext + cipher_block
        j = j + 16
        nonce = out
      
    return ciphertext

ciphertext = encryption_OFB(padded_plaintext,key,nonce) 
print(len(ciphertext))
print(ciphertext.hex())

"""**DECRYPTION FOR OFB**

"""

def decrypt_OFB(ciphertext,key,nonce):
    j = 0
    aescipher = AES.new(key, AES.MODE_ECB)
    recovered_plaintext = b''
    while j <= len(ciphertext)-16:
        cipher_block = ciphertext[j:j+16]
        out = aescipher.encrypt(nonce)
        plaintext_block = bytes([out[i] ^ cipher_block[i] for i in range(16)])
        recovered_plaintext = recovered_plaintext + plaintext_block  
        j = j + 16
        nonce = out
        print(plaintext_block)
    return recovered_plaintext

recovered_plaintext = decrypt_OFB (ciphertext,key,nonce)
print(recovered_plaintext)

##unpadding the message
unpad = m-n
plaintext = recovered_plaintext[:-unpad]
print("Data after unpadding: ",plaintext)